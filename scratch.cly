struct Time
{
	int hours;
	int minutes
	int seconds;

	int timezone;

	// I think I prefer option 1 here, then ^ can just be the address-of operator
	^int buffer1, buffer2;
	int^ buffer1, buffer2;

	// I think I prefer option 2 here, but it is inconsistent with my preference for
	//	the previous. I that
	[255]int buffer;
	int[255] buffer;
}

fun toTimezone(Time time, int newTimezone) -> (Time result, int oldTimezone)
{
	// Implicitly defined variables here named:
	// Time result;
	// int oldTimezone;

	int deltaTimezone = newTimezone - time.timezone;

	result.hours = time.hours + deltaTimezone;
	result.minutes = time.minutes;
	result.seconds = time.seconds;

	// 1)
	return result, time.timezone;

	// 2) Maybe? Since result was implicitly assigned.
	// return time.timezone;

	// 3) Maybe? No return value since both results are implicitly defined
	//	Could be error prone if we had a certain control path that didn't
	//	initialize it properly. Any more error prone than just having
	//	an explicit result variable that didn't get initialized properly?

	// oldTimezone = time.timezone;

	// 4) Maybe? Still require an explicit "return" to more explicitly document
	//	to the reader that we are actually returning things.
	//	return;

	// 5) Maybe? "naked" return is marked with a special word to indicate
	//	that it is a naked return. It would use whatever the word is for
	//	type inference (like "auto"). If you return values explicitly, then
	//	you have to provide *all* values.

	// return auto;
}

fun (Time, int) -> (Time, int) remapper = toTimezone;

func()->() remapper =
	func()
	{
	}


struct
{
}

identifier identifier = expr;



Type[245][123][45] j;
				   ^
				   | this is where we can tell that it is a var decl and not an expr...

could also be

ThreeDArrayOfFuncPointers[245][123][45]();


// Declarations go like this: type-modifier, type, name, optional: = value

[255]int buffer;
^int pBuffer;
^var myInt = 12;
[]var myBuffer = [ 15, 34 ]
int i;
var j = 12;

// Definitions (not reassignable at runtime) go link this:
//	Type keyword, name, rest of definition...

func (int)(float) sqrt
{
}

struct ConnectionInfo
{
	// members
	// members
	// members
};
// Note: inconsistent with the t

// for now parens are mandatory but that may be loosened


// Usage
buffer[12]
pBuffer[]	// Pointer dereference? implicit 0?